(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _ConsoleController = require('./controllers/ConsoleController');

var _ConsoleController2 = _interopRequireDefault(_ConsoleController);

var _fileupload = require('./directives/fileupload');

var _fileupload2 = _interopRequireDefault(_fileupload);

var _routes = require('./config/routes');

var _routes2 = _interopRequireDefault(_routes);

var _facebookOauth = require('./config/facebookOauth');

var _facebookOauth2 = _interopRequireDefault(_facebookOauth);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

console.log("window.modules", window.modules);

//import oAuthKeys from './services/oAuthKeys';
//import ProductService from './services/ProductService';

var app = angular.module('wingmanApp', ['ngResource', 'satellizer', 'angular-jwt', 'ui.router', 'angularMoment', 'ngFileUpload']).constant('API', '/manager/api').constant('FACEBOOK_API_KEY', '1204326232924507').controller('consoleController', _ConsoleController2.default).directive('fileModel', ['$parse', function ($parse) {
    return {
        restrict: 'A',
        link: function link(scope, element, attrs) {
            var model = $parse(attrs.fileModel);
            var modelSetter = model.assign;

            element.bind('change', function () {
                scope.$apply(function () {
                    modelSetter(scope, element[0].files[0]);
                });
            });
        }
    };
}]).config(["$stateProvider", "$urlRouterProvider", function ($stateProvider, $urlRouterProvider) {
    $stateProvider.state('home', {
        url: '/',
        templateUrl: 'views/login.html'
    }).state('login', {
        url: '/login',
        templateUrl: 'views/login.html'
    }).state('profile', {
        url: '/profile',
        templateUrl: 'views/profile.html'
    }).state('about', {
        url: '/about',
        templateUrl: 'views/about.html'
    }).state('dashboard', {
        url: '/dashboard',
        templateUrl: 'views/dashboard.html'
    }).state('users', {
        url: '/users',
        templateUrl: 'views/users.html'
    });
}]).config(["$authProvider", "$urlRouterProvider", "FACEBOOK_API_KEY", function ($authProvider, $urlRouterProvider, FACEBOOK_API_KEY) {
    $authProvider.facebook({
        url: 'api/auth/facebook', // this is the place we are telling Satilette to tell facebook to send back its post request to.
        clientId: FACEBOOK_API_KEY
    });

    $urlRouterProvider.otherwise('login');

    $authProvider.loginUrl = 'api/auth/login';
    $authProvider.signupUrl = 'api/auth/register';

    //.httpInterceptor = function(config) {
    //   return !!config.url.match(API_URL2);
    //};

    //$authProvider.tokenPrefix = null;
}]);

// var app = angular.module('wingmanApp', )
//   .constant('API', '/manager/api') 
//   //.config(InterceptorConfig)
//   .constant('FACEBOOK_API_KEY','1204326232924507')
//   .controller('consoleController', ConsoleController)
//   .directive('fileModel', ['$parse', function ($parse) {
//     return {
//         restrict: 'A',
//         link: function(scope, element, attrs) {
//             var model = $parse(attrs.fileModel);
//             var modelSetter = model.assign;

//             element.bind('change', function(){
//                 scope.$apply(function(){
//                     modelSetter(scope, element[0].files[0]);
//                 });
//             });
//         }
//     };
//     }])
//   .config(function ($stateProvider, $urlRouterProvider) {
//         $stateProvider
//              .state('home', {
//                 url: '/',
//                 templateUrl: 'views/login.html'
//             })
//              .state('login', {
//                 url: '/login',
//                 templateUrl: 'views/login.html'
//             })
//              .state('profile', {
//                 url: '/profile',
//                 templateUrl: 'views/profile.html'
//             })
//              .state('about', {
//                 url: '/about',
//                 templateUrl: 'views/about.html'
//             })
//              .state('dashboard', {
//                 url: '/dashboard',
//                 templateUrl: 'views/dashboard.html'
//             });
//   }).config(function ($authProvider,$urlRouterProvider, FACEBOOK_API_KEY){
//       $authProvider
//         .facebook({
//           url: 'api/auth/facebook', // this is the place we are telling Satilette to tell facebook to send back its post request to.
//           clientId: FACEBOOK_API_KEY
//         });

//         $urlRouterProvider.otherwise('login');

//         $authProvider.loginUrl  = 'api/auth/login';
//         $authProvider.signupUrl = 'api/auth/register';

//         //.httpInterceptor = function(config) {
//        //   return !!config.url.match(API_URL2);
//       //};

//     //$authProvider.tokenPrefix = null;

// });


/*InterceptorConfig.$inject = ['$httpProvider'];
function InterceptorConfig($httpProvider){
  $httpProvider.interceptors.push('AuthInterceptor');
}  ;*/

/*Router.$inject = ['$stateProvider', '$urlRouterProvider'];
function Router($stateProvider, $urlRouterProvider) {
  $stateProvider
  .state('home', {
    url: '/', 
    templateUrl: 'views/console.html'
  })
  .state('about', {
    url: '/about', 
    templateUrl: 'views/about.html'
  });
  $urlRouterProvider.otherwise('/');
}*/

},{"./config/facebookOauth":2,"./config/routes":3,"./controllers/ConsoleController":4,"./directives/fileupload":5}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function ($authProvider, $urlRouterProvider, FACEBOOK_API_KEY) {
  $authProvider.facebook({
    url: 'api/auth/facebook', // this is the place we are telling Satilette to tell facebook to send back its post request to.
    clientId: FACEBOOK_API_KEY
  });

  $urlRouterProvider.otherwise('login');

  $authProvider.loginUrl = 'api/auth/login';
  $authProvider.signupUrl = 'api/auth/register';
};

},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
   value: true
});

exports.default = function ($stateProvider, $urlRouterProvider) {
   $stateProvider.state('home', {
      url: '/',
      templateUrl: 'views/login.html'
   }).state('login', {
      url: '/login',
      templateUrl: 'views/login.html'
   }).state('profile', {
      url: '/profile',
      templateUrl: 'views/profile.html'
   }).state('about', {
      url: '/about',
      templateUrl: 'views/about.html'
   }).state('dashboard', {
      url: '/dashboard',
      templateUrl: 'views/dashboard.html'
   });
};

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function ConsoleController($scope, $http, $resource, $auth, $state, $window, Upload) {
  console.log('Main controller Angular');

  $scope.pointingtous = false;
  $scope.authenticated = false;
  $scope.nolocation = true;
  $scope.messages = [{ username: "app", message: "Loading..", timestamp: Date.now() }];
  $window.messages = [];
  $scope.inCity = "";
  $scope.texttosend = "";
  $scope.userList = [];

  $scope.login = { email: "", password: "", username: "" };

  var socket = window.io();

  $scope.usersPageInit = function () {

    $http({
      method: 'POST',
      url: '/api/users',
      data: { city: $scope.inCity }
    }).then(function (response) {
      console.log(response);

      $scope.userList = response.data;
    });
  };

  console.log("controller loaded");

  $scope.submit = function (file) {
    //function to call on form submit
    console.log("submit function called, file: ", file);
    if (file) {
      //check if from is valid
      $scope.upload(file); //call upload function
    }
  };
  $scope.upload = function (file) {
    Upload.upload({
      url: '/api/upload', //webAPI exposed to upload the file
      data: { file: file, login: $scope.login } //pass file as data, should be user ng-model
    }).then(function (resp) {
      //upload function returns a promise
      if (resp.data.error_code === 0) {
        //validate success
        $window.alert('Success ' + resp.config.data.file.name + 'uploaded. Response: ');
        $window.resp = resp;
      } else {
        $window.alert('an error occured');
      }
    }, function (resp) {
      //catch error
      console.log('Error status: ' + resp.status);
      $window.alert('Error status: ' + resp.status);
      $window.resp = resp.res;
    }, function (evt) {
      console.log(evt);
      var progressPercentage = parseInt(100.0 * evt.loaded / evt.total);
      console.log('progress: ' + progressPercentage + '% ' + evt.config.data.file.name);
      $scope.progress = 'progress: ' + progressPercentage + '% '; // capture upload progress
    });
  };

  /*  $scope.isAuth = function(){
       $scope.authenticated ? '' : $state.go('login');
    }*/

  $window.state = $state;

  $scope.isAuth = function () {
    $scope.isAuthenticated = $auth.isAuthenticated();

    if ($scope.isAuthenticated) {
      $scope.payload = $auth.getPayload();

      if ($state.current.name == "login") {
        $state.go('dashboard');
      }

      console.log("payload", $scope.payload);

      $scope.login.profilepicture = $scope.payload._doc.image;
      $scope.login.usertype = $scope.payload._doc.type;
      $scope.login.username = $scope.payload._doc.username;
      $scope.login.lastLatLng = $scope.payload._doc.lastLatLng;
    } else {
      $state.go('login'); // go back to login page
    }
  };

  $scope.logout = function () {
    $auth.logout();
  };

  // sign in with facebook
  $scope.authenticate = function (provider) {
    $auth.authenticate(provider);
  };

  $scope.helloworld = "hello world from $scope now its not even doing it";

  $scope.submitLogin = function () {
    console.log("email: ", $scope.login.email, "password: ", $scope.login.password);
    $auth.login($scope.login).then(function (response) {
      console.log(response);
      $scope.login.profilepicture = response.data.user.image;
      console.log("$scope.login", $scope.login);

      $state.go('dashboard');
      $scope.sendSocket($scope.login.username);
    }).catch(function (err) {
      $scope.authMessage = 'not authenticated, please either register, or recover your password?';
    });
  };

  $scope.submitRegister = function () {
    console.log("email: ", $scope.login.email, "password: ", $scope.login.password);
    $auth.signup($scope.login).then(function (response) {
      console.log(response);

      $state.go('dashboard');
      $scope.sendSocket($scope.login.username);
    });
  };

  $scope.logout = function () {
    console.log("email: ", $scope.login.email, "password: ", $scope.login.password);
    $auth.logout();
    $scope.authenticated = false;
    $state.go('login');
  };

  /// GEO LOCATION STUFF

  function getLocation() {
    var msg;

    if ('geolocation' in window.navigator) {

      console.log("browser supports geolocation, going to call requestLocation() function");

      requestLocation();
    } else {
      // no geolocation :(
      msg = "Sorry, looks like your browser doesn't support geolocation";
      outputResult(msg); // output error message
    }

    function requestLocation() {
      /**
      getCurrentPosition() below accepts 3 arguments:
      a success callback (required), an error callback  (optional), and a set of options (optional)
      **/

      var options = {
        // enableHighAccuracy = should the device take extra time or power to return a really accurate result, or should it give you the quick (but less accurate) answer?
        enableHighAccuracy: false,
        // timeout = how long does the device have, in milliseconds to return a result?
        timeout: 5000,
        // maximumAge = maximum age for a possible previously-cached position. 0 = must return the current position, not a prior cached position
        maximumAge: 0
      };

      // call getCurrentPosition()
      window.navigator.geolocation.getCurrentPosition(success, error, options);

      // upon success, do this
      function success(pos) {
        // get longitude and latitude from the position object passed in


        var geocoords = { lng: pos.coords.longitude, lat: pos.coords.latitude }; //{lat:  "51.4937728", lng: "-0.1422" }//

        // needs to calculate nearest city using GOOGLE. (in order to create rooms/ something like that with sockets)
        //$http.post('', geocoords, config).then(successCallback, errorCallback);

        console.log("geocoords are: ", geocoords);
        // send back their location to the server (via sockets)
        $scope.sendSocket($scope.login.username, geocoords);
        // and presto, we have the device's location!
        msg = 'You appear to be at longitude: ' + geocoords.lng + ' and latitude: ' + geocoords.lat + '<img src="http://maps.googleapis.com/maps/api/staticmap?zoom=15&size=300x300&maptype=roadmap&markers=color:red%7Clabel:A%7C' + geocoords.lat + ',' + geocoords.lng + '&sensor=false">';
        //outputResult(msg); // output message
      }

      // upon error, do this
      function error(err) {
        // return the error message
        msg = 'Error: ' + err + ' :(';
        //outputResult(msg); // output button
        $('.pure-button').removeClass('pure-button-primary').addClass('pure-button-error'); // change button style
      }
    } // end requestLocation();

  } // end getLocation()


  // plot a map with markers of all recently logged in users
  $scope.plotusers = function (lat, lng, data) {

    console.log("lat/lng", lng, lat);

    var marker_these_users = [];

    var i = 0;
    for (i in data.lastLogs) {
      if (data.lastLogs[i].username != $scope.login.username) {
        marker_these_users.push(data.lastLogs[i]);
      }
    }
    console.log("going to add these users to the map", marker_these_users);
    $window.marker_these_users = marker_these_users;

    // map options
    var options = {
      zoom: 13,
      center: new google.maps.LatLng(lat, lng), // centered US
      mapTypeId: google.maps.MapTypeId.TERRAIN,
      mapTypeControl: false
    };

    // init map
    var map = new google.maps.Map(document.getElementById('map-result'), options);

    // NY and CA sample Lat / Lng
    var southWest = new google.maps.LatLng(40.744656, -74.005966);
    var northEast = new google.maps.LatLng(34.052234, -118.243685);
    var lngSpan = northEast.lng() - southWest.lng();
    var latSpan = northEast.lat() - southWest.lat();

    // set multiple marker
    var i = 0;
    for (i in marker_these_users) {
      // init markers
      var marker = new google.maps.Marker({
        position: new google.maps.LatLng(marker_these_users[i].geocoords.lat, marker_these_users[i].geocoords.lng),
        map: map,
        title: 'Click Me '
      });

      // process multiple info windows
      (function (marker, i) {
        // add click event
        google.maps.event.addListener(marker, 'click', function () {
          $window.infowindow = new google.maps.InfoWindow({
            content: 'Hello, World!!'
          });
          infowindow.open(map, marker);
        });
      })(marker, i);
    }
  };

  $scope.getMyLocationbtn = function () {
    console.log("clicked on getmylocation btn");
    // show spinner while getlocation() does its thing
    $('.result').html('<i class="fa fa-spinner fa-spin"></i>');
    getLocation();
  };

  // Google Returns local businesses and stuff


  // Sockets sends location of user
  $scope.sendSocket = function (username, geocoords) {
    socket.emit('newconnection', { message: "a new user has connected", username: username, geocoords: geocoords });
  };

  $scope.sendmessage = function (texttosend) {
    var themessage = { text: texttosend, inCity: $scope.inCity, username: $scope.login.username, timestamp: Date.now() };
    console.log("themessage", themessage);
    socket.emit('chatmessage', themessage);
  };

  // sockets returns the last seen location of other users

  socket.on('message', function (message) {
    console.log("socket - message: ", message);
    $scope.$apply(function () {
      $scope.messages.push(message);
    });
  });

  $window.seeMessages = function () {
    console.log($scope.messages);
  };

  socket.on('data', function (data) {
    console.log("socket - data: ", data);
    if (data.event == "locationupdated") {
      $scope.inCity = data.inCity;

      $scope.$apply(function () {
        $scope.nolocation = !$scope.nolocation;
        $scope.plotusers(data.urLatLng.lat, data.urLatLng.lng, data);
      });
      console.log("location has been updated");
    }
  });

  $scope.addtoarray = function () {
    $scope.messages.push($scope.trythis);
  };
}
exports.default = ConsoleController;

},{}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function ($parse) {

    return {
        restrict: 'A',
        link: function link(scope, element, attrs) {
            var model = $parse(attrs.fileModel);
            var modelSetter = model.assign;

            element.bind('change', function () {
                scope.$apply(function () {
                    modelSetter(scope, element[0].files[0]);
                });
            });
        }
    };
};

},{}]},{},[1])


//# sourceMappingURL=app.min.js.map
